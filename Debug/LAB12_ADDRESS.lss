
LAB12_ADDRESS.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000300  00000000  00000000  00000074  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000020  00800060  00000300  00000374  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .stab         000007bc  00000000  00000000  00000394  2**2
                  CONTENTS, READONLY, DEBUGGING
  3 .stabstr      00000183  00000000  00000000  00000b50  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .comment      0000002f  00000000  00000000  00000cd3  2**0
                  CONTENTS, READONLY
  5 .debug_aranges 000000c8  00000000  00000000  00000d02  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   000006ba  00000000  00000000  00000dca  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000002f6  00000000  00000000  00001484  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00000333  00000000  00000000  0000177a  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000001ec  00000000  00000000  00001ab0  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000001e1  00000000  00000000  00001c9c  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000004cb  00000000  00000000  00001e7d  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000098  00000000  00000000  00002348  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
   4:	0c 94 3f 00 	jmp	0x7e	; 0x7e <__bad_interrupt>
   8:	0c 94 3f 00 	jmp	0x7e	; 0x7e <__bad_interrupt>
   c:	0c 94 3f 00 	jmp	0x7e	; 0x7e <__bad_interrupt>
  10:	0c 94 3f 00 	jmp	0x7e	; 0x7e <__bad_interrupt>
  14:	0c 94 3f 00 	jmp	0x7e	; 0x7e <__bad_interrupt>
  18:	0c 94 3f 00 	jmp	0x7e	; 0x7e <__bad_interrupt>
  1c:	0c 94 3f 00 	jmp	0x7e	; 0x7e <__bad_interrupt>
  20:	0c 94 3f 00 	jmp	0x7e	; 0x7e <__bad_interrupt>
  24:	0c 94 3f 00 	jmp	0x7e	; 0x7e <__bad_interrupt>
  28:	0c 94 3f 00 	jmp	0x7e	; 0x7e <__bad_interrupt>
  2c:	0c 94 3f 00 	jmp	0x7e	; 0x7e <__bad_interrupt>
  30:	0c 94 3f 00 	jmp	0x7e	; 0x7e <__bad_interrupt>
  34:	0c 94 71 00 	jmp	0xe2	; 0xe2 <__vector_13>
  38:	0c 94 3f 00 	jmp	0x7e	; 0x7e <__bad_interrupt>
  3c:	0c 94 3f 00 	jmp	0x7e	; 0x7e <__bad_interrupt>
  40:	0c 94 3f 00 	jmp	0x7e	; 0x7e <__bad_interrupt>
  44:	0c 94 3f 00 	jmp	0x7e	; 0x7e <__bad_interrupt>
  48:	0c 94 3f 00 	jmp	0x7e	; 0x7e <__bad_interrupt>
  4c:	0c 94 3f 00 	jmp	0x7e	; 0x7e <__bad_interrupt>
  50:	0c 94 3f 00 	jmp	0x7e	; 0x7e <__bad_interrupt>

00000054 <__ctors_end>:
  54:	11 24       	eor	r1, r1
  56:	1f be       	out	0x3f, r1	; 63
  58:	cf e5       	ldi	r28, 0x5F	; 95
  5a:	d8 e0       	ldi	r29, 0x08	; 8
  5c:	de bf       	out	0x3e, r29	; 62
  5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
  60:	10 e0       	ldi	r17, 0x00	; 0
  62:	a0 e6       	ldi	r26, 0x60	; 96
  64:	b0 e0       	ldi	r27, 0x00	; 0
  66:	e0 e0       	ldi	r30, 0x00	; 0
  68:	f3 e0       	ldi	r31, 0x03	; 3
  6a:	02 c0       	rjmp	.+4      	; 0x70 <__do_copy_data+0x10>
  6c:	05 90       	lpm	r0, Z+
  6e:	0d 92       	st	X+, r0
  70:	a0 38       	cpi	r26, 0x80	; 128
  72:	b1 07       	cpc	r27, r17
  74:	d9 f7       	brne	.-10     	; 0x6c <__do_copy_data+0xc>
  76:	0e 94 41 00 	call	0x82	; 0x82 <main>
  7a:	0c 94 7e 01 	jmp	0x2fc	; 0x2fc <_exit>

0000007e <__bad_interrupt>:
  7e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000082 <main>:
int main()
{
	char * Buffer;
	
	// Initialize USART (with RX interrupt enable)
	InitUART(9600, 8, 1);
  82:	21 e0       	ldi	r18, 0x01	; 1
  84:	48 e0       	ldi	r20, 0x08	; 8
  86:	60 e8       	ldi	r22, 0x80	; 128
  88:	75 e2       	ldi	r23, 0x25	; 37
  8a:	80 e0       	ldi	r24, 0x00	; 0
  8c:	90 e0       	ldi	r25, 0x00	; 0
  8e:	0e 94 df 00 	call	0x1be	; 0x1be <InitUART>
	// Global interrupt enable
	sei();
  92:	78 94       	sei
	// Initialize LED port
	initLEDport();
  94:	0e 94 bc 00 	call	0x178	; 0x178 <initLEDport>
  98:	ff cf       	rjmp	.-2      	; 0x98 <main+0x16>

0000009a <taendlys>:
		// Her kunne man lave noget "fornuftigt"
	}

}

void taendlys(int ID){
  9a:	cf 93       	push	r28
  9c:	c8 2f       	mov	r28, r24
	
	// Toggle aktuelle lysdiode
	turnOnLED(ID - '0');
  9e:	80 53       	subi	r24, 0x30	; 48
  a0:	0e 94 d0 00 	call	0x1a0	; 0x1a0 <turnOnLED>
	// Send streng "LED nummer x er toggled"
	SendString("LED nummer ");
  a4:	80 e6       	ldi	r24, 0x60	; 96
  a6:	90 e0       	ldi	r25, 0x00	; 0
  a8:	0e 94 29 01 	call	0x252	; 0x252 <SendString>
	SendChar(ID);
  ac:	8c 2f       	mov	r24, r28
  ae:	0e 94 25 01 	call	0x24a	; 0x24a <SendChar>
	SendString(" er toggled\r\n");
  b2:	8c e6       	ldi	r24, 0x6C	; 108
  b4:	90 e0       	ldi	r25, 0x00	; 0
  b6:	0e 94 29 01 	call	0x252	; 0x252 <SendString>
	
}
  ba:	cf 91       	pop	r28
  bc:	08 95       	ret

000000be <sluklys>:

void sluklys(int ID){
  be:	cf 93       	push	r28
  c0:	c8 2f       	mov	r28, r24
	
	// Toggle aktuelle lysdiode
	turnOffLED(ID - '0');
  c2:	80 53       	subi	r24, 0x30	; 48
  c4:	0e 94 c0 00 	call	0x180	; 0x180 <turnOffLED>
	// Send streng "LED nummer x er toggled"
	SendString("LED nummer ");
  c8:	80 e6       	ldi	r24, 0x60	; 96
  ca:	90 e0       	ldi	r25, 0x00	; 0
  cc:	0e 94 29 01 	call	0x252	; 0x252 <SendString>
	SendChar(ID);
  d0:	8c 2f       	mov	r24, r28
  d2:	0e 94 25 01 	call	0x24a	; 0x24a <SendChar>
	SendString(" er toggled\r\n");
  d6:	8c e6       	ldi	r24, 0x6C	; 108
  d8:	90 e0       	ldi	r25, 0x00	; 0
  da:	0e 94 29 01 	call	0x252	; 0x252 <SendString>
	
  de:	cf 91       	pop	r28
  e0:	08 95       	ret

000000e2 <__vector_13>:
#include "uart_int.h"
#include "led.h"
#include "main.h"

ISR (USART_RXC_vect)
{
  e2:	1f 92       	push	r1
  e4:	0f 92       	push	r0
  e6:	0f b6       	in	r0, 0x3f	; 63
  e8:	0f 92       	push	r0
  ea:	11 24       	eor	r1, r1
  ec:	2f 93       	push	r18
  ee:	3f 93       	push	r19
  f0:	4f 93       	push	r20
  f2:	5f 93       	push	r21
  f4:	6f 93       	push	r22
  f6:	7f 93       	push	r23
  f8:	8f 93       	push	r24
  fa:	9f 93       	push	r25
  fc:	af 93       	push	r26
  fe:	bf 93       	push	r27
 100:	ef 93       	push	r30
 102:	ff 93       	push	r31
 104:	cf 93       	push	r28
 106:	df 93       	push	r29
 108:	00 d0       	rcall	.+0      	; 0x10a <__vector_13+0x28>
 10a:	00 d0       	rcall	.+0      	; 0x10c <__vector_13+0x2a>
 10c:	cd b7       	in	r28, 0x3d	; 61
 10e:	de b7       	in	r29, 0x3e	; 62
	char buffer[4];
	
	
	ReadString(&buffer,ARRAY);
 110:	64 e0       	ldi	r22, 0x04	; 4
 112:	70 e0       	ldi	r23, 0x00	; 0
 114:	ce 01       	movw	r24, r28
 116:	01 96       	adiw	r24, 0x01	; 1
 118:	0e 94 38 01 	call	0x270	; 0x270 <ReadString>
	if (buffer[0]== '!' || buffer[0]=='?')
 11c:	89 81       	ldd	r24, Y+1	; 0x01
 11e:	81 32       	cpi	r24, 0x21	; 33
 120:	11 f0       	breq	.+4      	; 0x126 <__vector_13+0x44>
 122:	8f 33       	cpi	r24, 0x3F	; 63
 124:	91 f4       	brne	.+36     	; 0x14a <__vector_13+0x68>
	{
		if (buffer[2] == '0')
 126:	8b 81       	ldd	r24, Y+3	; 0x03
 128:	80 33       	cpi	r24, 0x30	; 48
 12a:	49 f4       	brne	.+18     	; 0x13e <__vector_13+0x5c>
		{
			taendlys(buffer[1]);
 12c:	8a 81       	ldd	r24, Y+2	; 0x02
 12e:	90 e0       	ldi	r25, 0x00	; 0
 130:	0e 94 4d 00 	call	0x9a	; 0x9a <taendlys>
			SendString("Lol\r\n");
 134:	8a e7       	ldi	r24, 0x7A	; 122
 136:	90 e0       	ldi	r25, 0x00	; 0
 138:	0e 94 29 01 	call	0x252	; 0x252 <SendString>
 13c:	06 c0       	rjmp	.+12     	; 0x14a <__vector_13+0x68>
		}
		else if (buffer[2]== 'f')
 13e:	86 36       	cpi	r24, 0x66	; 102
 140:	21 f4       	brne	.+8      	; 0x14a <__vector_13+0x68>
		{
			sluklys(buffer[1]);
 142:	8a 81       	ldd	r24, Y+2	; 0x02
 144:	90 e0       	ldi	r25, 0x00	; 0
 146:	0e 94 5f 00 	call	0xbe	; 0xbe <sluklys>
		}
	}

}
 14a:	0f 90       	pop	r0
 14c:	0f 90       	pop	r0
 14e:	0f 90       	pop	r0
 150:	0f 90       	pop	r0
 152:	df 91       	pop	r29
 154:	cf 91       	pop	r28
 156:	ff 91       	pop	r31
 158:	ef 91       	pop	r30
 15a:	bf 91       	pop	r27
 15c:	af 91       	pop	r26
 15e:	9f 91       	pop	r25
 160:	8f 91       	pop	r24
 162:	7f 91       	pop	r23
 164:	6f 91       	pop	r22
 166:	5f 91       	pop	r21
 168:	4f 91       	pop	r20
 16a:	3f 91       	pop	r19
 16c:	2f 91       	pop	r18
 16e:	0f 90       	pop	r0
 170:	0f be       	out	0x3f, r0	; 63
 172:	0f 90       	pop	r0
 174:	1f 90       	pop	r1
 176:	18 95       	reti

00000178 <initLEDport>:
#define MAX_LED_NR 7

void initLEDport()
{
  // Sæt alle PORTC's ben til at være udgange 
  DDRC = 0b11111111;
 178:	8f ef       	ldi	r24, 0xFF	; 255
 17a:	84 bb       	out	0x14, r24	; 20
  // Sluk alle lysdioderne
  PORTC = 0xFF;     
 17c:	85 bb       	out	0x15, r24	; 21
 17e:	08 95       	ret

00000180 <turnOffLED>:
void turnOffLED(unsigned char led_nr)
{
// Lokal variabel
unsigned char mask;
  // Vi skal kun lave noget, hvis led_nr < 8
  if (led_nr <= MAX_LED_NR)
 180:	88 30       	cpi	r24, 0x08	; 8
 182:	68 f4       	brcc	.+26     	; 0x19e <turnOffLED+0x1e>
  {
    // Dan maske på basis af parameteren (led_nr)
    mask = ~(0b00000001 << led_nr);
    // Tænd den aktuelle lysdiode (de andre ændres ikke)
    PORTC = PORTC & mask;
 184:	45 b3       	in	r20, 0x15	; 21
unsigned char mask;
  // Vi skal kun lave noget, hvis led_nr < 8
  if (led_nr <= MAX_LED_NR)
  {
    // Dan maske på basis af parameteren (led_nr)
    mask = ~(0b00000001 << led_nr);
 186:	21 e0       	ldi	r18, 0x01	; 1
 188:	30 e0       	ldi	r19, 0x00	; 0
 18a:	b9 01       	movw	r22, r18
 18c:	02 c0       	rjmp	.+4      	; 0x192 <turnOffLED+0x12>
 18e:	66 0f       	add	r22, r22
 190:	77 1f       	adc	r23, r23
 192:	8a 95       	dec	r24
 194:	e2 f7       	brpl	.-8      	; 0x18e <turnOffLED+0xe>
 196:	cb 01       	movw	r24, r22
 198:	80 95       	com	r24
    // Tænd den aktuelle lysdiode (de andre ændres ikke)
    PORTC = PORTC & mask;
 19a:	84 23       	and	r24, r20
 19c:	85 bb       	out	0x15, r24	; 21
 19e:	08 95       	ret

000001a0 <turnOnLED>:
void turnOnLED(unsigned char led_nr)
{
// Lokal variabel
unsigned char mask;
  // Vi skal kun lave noget, hvis led_nr < 8
  if (led_nr <= MAX_LED_NR)
 1a0:	88 30       	cpi	r24, 0x08	; 8
 1a2:	60 f4       	brcc	.+24     	; 0x1bc <turnOnLED+0x1c>
  {
    // Dan maske på basis af parameteren (led_nr)
    mask = 0b00000001 << led_nr;
    // Sluk den aktuelle lysdiode (de andre ændres ikke)
    PORTC = PORTC | mask;
 1a4:	45 b3       	in	r20, 0x15	; 21
unsigned char mask;
  // Vi skal kun lave noget, hvis led_nr < 8
  if (led_nr <= MAX_LED_NR)
  {
    // Dan maske på basis af parameteren (led_nr)
    mask = 0b00000001 << led_nr;
 1a6:	21 e0       	ldi	r18, 0x01	; 1
 1a8:	30 e0       	ldi	r19, 0x00	; 0
 1aa:	b9 01       	movw	r22, r18
 1ac:	02 c0       	rjmp	.+4      	; 0x1b2 <turnOnLED+0x12>
 1ae:	66 0f       	add	r22, r22
 1b0:	77 1f       	adc	r23, r23
 1b2:	8a 95       	dec	r24
 1b4:	e2 f7       	brpl	.-8      	; 0x1ae <turnOnLED+0xe>
 1b6:	cb 01       	movw	r24, r22
    // Sluk den aktuelle lysdiode (de andre ændres ikke)
    PORTC = PORTC | mask;
 1b8:	84 2b       	or	r24, r20
 1ba:	85 bb       	out	0x15, r24	; 21
 1bc:	08 95       	ret

000001be <InitUART>:
Parameters:
	BaudRate: Wanted Baud Rate.
	Databits: Wanted number of Data Bits.
*************************************************************************/
void InitUART(unsigned long BaudRate, unsigned char DataBit, unsigned char RX_int  )
{
 1be:	0f 93       	push	r16
 1c0:	1f 93       	push	r17
 1c2:	52 2f       	mov	r21, r18
unsigned int TempUBRR;

  if ((BaudRate >= 110) && (BaudRate <= 115200) && (DataBit >=5) && (DataBit <= 8))
 1c4:	8b 01       	movw	r16, r22
 1c6:	9c 01       	movw	r18, r24
 1c8:	0e 56       	subi	r16, 0x6E	; 110
 1ca:	11 09       	sbc	r17, r1
 1cc:	21 09       	sbc	r18, r1
 1ce:	31 09       	sbc	r19, r1
 1d0:	03 39       	cpi	r16, 0x93	; 147
 1d2:	11 4c       	sbci	r17, 0xC1	; 193
 1d4:	21 40       	sbci	r18, 0x01	; 1
 1d6:	31 05       	cpc	r19, r1
 1d8:	88 f5       	brcc	.+98     	; 0x23c <InitUART+0x7e>
 1da:	45 30       	cpi	r20, 0x05	; 5
 1dc:	78 f1       	brcs	.+94     	; 0x23c <InitUART+0x7e>
 1de:	49 30       	cpi	r20, 0x09	; 9
 1e0:	68 f5       	brcc	.+90     	; 0x23c <InitUART+0x7e>
  { 
    // "Normal" clock, no multiprocesser mode (= default)
    UCSRA = 0b00100000;
 1e2:	20 e2       	ldi	r18, 0x20	; 32
 1e4:	2b b9       	out	0x0b, r18	; 11
    // No interrupts enabled
    // Receiver enabled
    // Transmitter enabled
    // No 9 bit operation
    UCSRB = 0b00011000;
 1e6:	28 e1       	ldi	r18, 0x18	; 24
 1e8:	2a b9       	out	0x0a, r18	; 10
    // Enable RX interrupts if wanted
    if (RX_int)
 1ea:	51 11       	cpse	r21, r1
      UCSRB |= 0b10000000;
 1ec:	57 9a       	sbi	0x0a, 7	; 10
    // Asynchronous operation, 1 stop bit, no parity
    // Bit7 always has to be 1
    // Bit 2 and bit 1 controlles the number of databits
    UCSRC = 0b10000000 | (DataBit-5)<<1;
 1ee:	24 2f       	mov	r18, r20
 1f0:	30 e0       	ldi	r19, 0x00	; 0
 1f2:	25 50       	subi	r18, 0x05	; 5
 1f4:	31 09       	sbc	r19, r1
 1f6:	22 0f       	add	r18, r18
 1f8:	33 1f       	adc	r19, r19
 1fa:	20 68       	ori	r18, 0x80	; 128
 1fc:	3f 6f       	ori	r19, 0xFF	; 255
 1fe:	20 bd       	out	0x20, r18	; 32
    // Set Baud Rate according to the parameter BaudRate:
    // Select Baud Rate (first store "UBRRH--UBRRL" in local 16-bit variable,
    //                   then write the two 8-bit registers seperately):
    TempUBRR = XTAL/(16*BaudRate) - 1;
 200:	dc 01       	movw	r26, r24
 202:	cb 01       	movw	r24, r22
 204:	88 0f       	add	r24, r24
 206:	99 1f       	adc	r25, r25
 208:	aa 1f       	adc	r26, r26
 20a:	bb 1f       	adc	r27, r27
 20c:	88 0f       	add	r24, r24
 20e:	99 1f       	adc	r25, r25
 210:	aa 1f       	adc	r26, r26
 212:	bb 1f       	adc	r27, r27
 214:	9c 01       	movw	r18, r24
 216:	ad 01       	movw	r20, r26
 218:	22 0f       	add	r18, r18
 21a:	33 1f       	adc	r19, r19
 21c:	44 1f       	adc	r20, r20
 21e:	55 1f       	adc	r21, r21
 220:	22 0f       	add	r18, r18
 222:	33 1f       	adc	r19, r19
 224:	44 1f       	adc	r20, r20
 226:	55 1f       	adc	r21, r21
 228:	60 e0       	ldi	r22, 0x00	; 0
 22a:	70 e4       	ldi	r23, 0x40	; 64
 22c:	88 e3       	ldi	r24, 0x38	; 56
 22e:	90 e0       	ldi	r25, 0x00	; 0
 230:	0e 94 5c 01 	call	0x2b8	; 0x2b8 <__udivmodsi4>
 234:	21 50       	subi	r18, 0x01	; 1
 236:	31 09       	sbc	r19, r1
    // Write upper part of UBRR
    UBRRH = TempUBRR >> 8;
 238:	30 bd       	out	0x20, r19	; 32
    // Write lower part of UBRR
    UBRRL = TempUBRR;
 23a:	29 b9       	out	0x09, r18	; 9
  }  
}
 23c:	1f 91       	pop	r17
 23e:	0f 91       	pop	r16
 240:	08 95       	ret

00000242 <ReadChar>:
Then this character is returned.
*************************************************************************/
char ReadChar()
{
  // Wait for new character received
  while ( (UCSRA & (1<<7)) == 0 )
 242:	5f 9b       	sbis	0x0b, 7	; 11
 244:	fe cf       	rjmp	.-4      	; 0x242 <ReadChar>
  {}                        
  // Then return it
  return UDR;
 246:	8c b1       	in	r24, 0x0c	; 12
}
 248:	08 95       	ret

0000024a <SendChar>:
	Tegn : Character for sending. 
*************************************************************************/
void SendChar(char Tegn)
{
  // Wait for transmitter register empty (ready for new character)
  while ( (UCSRA & (1<<5)) == 0 )
 24a:	5d 9b       	sbis	0x0b, 5	; 11
 24c:	fe cf       	rjmp	.-4      	; 0x24a <SendChar>
  {}
  // Then send the character
  UDR = Tegn;
 24e:	8c b9       	out	0x0c, r24	; 12
 250:	08 95       	ret

00000252 <SendString>:
Sends 0-terminated string.
Parameter:
   Streng: Pointer to the string. 
*************************************************************************/
void SendString(char* Streng)
{
 252:	cf 93       	push	r28
 254:	df 93       	push	r29
 256:	ec 01       	movw	r28, r24
  // Repeat untill zero-termination
  while (*Streng != 0)
 258:	88 81       	ld	r24, Y
 25a:	88 23       	and	r24, r24
 25c:	31 f0       	breq	.+12     	; 0x26a <SendString+0x18>
/*************************************************************************
Sends 0-terminated string.
Parameter:
   Streng: Pointer to the string. 
*************************************************************************/
void SendString(char* Streng)
 25e:	21 96       	adiw	r28, 0x01	; 1
{
  // Repeat untill zero-termination
  while (*Streng != 0)
  {
    // Send the character pointed to by "Streng"
    SendChar(*Streng);
 260:	0e 94 25 01 	call	0x24a	; 0x24a <SendChar>
   Streng: Pointer to the string. 
*************************************************************************/
void SendString(char* Streng)
{
  // Repeat untill zero-termination
  while (*Streng != 0)
 264:	89 91       	ld	r24, Y+
 266:	81 11       	cpse	r24, r1
 268:	fb cf       	rjmp	.-10     	; 0x260 <SendString+0xe>
    // Send the character pointed to by "Streng"
    SendChar(*Streng);
    // Advance the pointer one step
    Streng++;
  }
}
 26a:	df 91       	pop	r29
 26c:	cf 91       	pop	r28
 26e:	08 95       	ret

00000270 <ReadString>:

/**************************************************/


void ReadString(char* Buffer, int MaxLenght)
{
 270:	ef 92       	push	r14
 272:	ff 92       	push	r15
 274:	0f 93       	push	r16
 276:	1f 93       	push	r17
 278:	cf 93       	push	r28
 27a:	df 93       	push	r29
 27c:	8c 01       	movw	r16, r24
 27e:	7b 01       	movw	r14, r22
	char NextChar;
	int StringLenght=0;
	
	NextChar = ReadChar();
 280:	0e 94 21 01 	call	0x242	; 0x242 <ReadChar>
	
	while (NextChar != '\r' && StringLenght < MaxLenght)
 284:	8d 30       	cpi	r24, 0x0D	; 13
 286:	79 f0       	breq	.+30     	; 0x2a6 <ReadString+0x36>
 288:	1e 14       	cp	r1, r14
 28a:	1f 04       	cpc	r1, r15
 28c:	64 f4       	brge	.+24     	; 0x2a6 <ReadString+0x36>
 28e:	e8 01       	movw	r28, r16
}

/**************************************************/


void ReadString(char* Buffer, int MaxLenght)
 290:	e0 0e       	add	r14, r16
 292:	f1 1e       	adc	r15, r17
	
	NextChar = ReadChar();
	
	while (NextChar != '\r' && StringLenght < MaxLenght)
	{
		*Buffer++ = NextChar;
 294:	89 93       	st	Y+, r24
 296:	8e 01       	movw	r16, r28
		StringLenght++;
		NextChar = ReadChar();
 298:	0e 94 21 01 	call	0x242	; 0x242 <ReadChar>
	char NextChar;
	int StringLenght=0;
	
	NextChar = ReadChar();
	
	while (NextChar != '\r' && StringLenght < MaxLenght)
 29c:	8d 30       	cpi	r24, 0x0D	; 13
 29e:	19 f0       	breq	.+6      	; 0x2a6 <ReadString+0x36>
 2a0:	ce 15       	cp	r28, r14
 2a2:	df 05       	cpc	r29, r15
 2a4:	b9 f7       	brne	.-18     	; 0x294 <ReadString+0x24>
	{
		*Buffer++ = NextChar;
		StringLenght++;
		NextChar = ReadChar();
	}
	*Buffer = '\0';
 2a6:	f8 01       	movw	r30, r16
 2a8:	10 82       	st	Z, r1
}
 2aa:	df 91       	pop	r29
 2ac:	cf 91       	pop	r28
 2ae:	1f 91       	pop	r17
 2b0:	0f 91       	pop	r16
 2b2:	ff 90       	pop	r15
 2b4:	ef 90       	pop	r14
 2b6:	08 95       	ret

000002b8 <__udivmodsi4>:
 2b8:	a1 e2       	ldi	r26, 0x21	; 33
 2ba:	1a 2e       	mov	r1, r26
 2bc:	aa 1b       	sub	r26, r26
 2be:	bb 1b       	sub	r27, r27
 2c0:	fd 01       	movw	r30, r26
 2c2:	0d c0       	rjmp	.+26     	; 0x2de <__udivmodsi4_ep>

000002c4 <__udivmodsi4_loop>:
 2c4:	aa 1f       	adc	r26, r26
 2c6:	bb 1f       	adc	r27, r27
 2c8:	ee 1f       	adc	r30, r30
 2ca:	ff 1f       	adc	r31, r31
 2cc:	a2 17       	cp	r26, r18
 2ce:	b3 07       	cpc	r27, r19
 2d0:	e4 07       	cpc	r30, r20
 2d2:	f5 07       	cpc	r31, r21
 2d4:	20 f0       	brcs	.+8      	; 0x2de <__udivmodsi4_ep>
 2d6:	a2 1b       	sub	r26, r18
 2d8:	b3 0b       	sbc	r27, r19
 2da:	e4 0b       	sbc	r30, r20
 2dc:	f5 0b       	sbc	r31, r21

000002de <__udivmodsi4_ep>:
 2de:	66 1f       	adc	r22, r22
 2e0:	77 1f       	adc	r23, r23
 2e2:	88 1f       	adc	r24, r24
 2e4:	99 1f       	adc	r25, r25
 2e6:	1a 94       	dec	r1
 2e8:	69 f7       	brne	.-38     	; 0x2c4 <__udivmodsi4_loop>
 2ea:	60 95       	com	r22
 2ec:	70 95       	com	r23
 2ee:	80 95       	com	r24
 2f0:	90 95       	com	r25
 2f2:	9b 01       	movw	r18, r22
 2f4:	ac 01       	movw	r20, r24
 2f6:	bd 01       	movw	r22, r26
 2f8:	cf 01       	movw	r24, r30
 2fa:	08 95       	ret

000002fc <_exit>:
 2fc:	f8 94       	cli

000002fe <__stop_program>:
 2fe:	ff cf       	rjmp	.-2      	; 0x2fe <__stop_program>
